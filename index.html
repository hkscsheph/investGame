<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serverless Invest Game (Visualized)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        body { font-family: "Microsoft JhengHei", sans-serif; background: #f4f4f9; padding: 20px; }
        .container { max-width: 950px; margin: auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .hidden { display: none !important; }
        .btn { width: 100%; padding: 12px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; margin-top: 5px; font-size: 15px; }
        .btn:hover { background: #2980b9; }
        .btn-gm { background: #e74c3c; }
        .btn-gm:hover { background: #c0392b; }
        .btn-small { width: auto; padding: 5px 10px; font-size: 0.9em; }
        
        .chart-container { position: relative; height: 350px; width: 100%; margin-bottom: 20px; }
        .row { display: flex; gap: 20px; margin-bottom: 20px; }
        .col { flex: 1; }
        .stats-bar { display: flex; justify-content: space-around; background: #ecf0f1; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-weight: bold; font-size: 1.2em; }
        
        .control-group { padding: 12px; border: 1px solid #eee; border-radius: 8px; margin-bottom: 10px; background: #fff; }
        .alloc-header { display: flex; justify-content: space-between; margin-bottom: 5px; font-weight: bold; }
        .alloc-percent { color: #2980b9; }
        
        input[type=number] { padding: 5px; width: 70px; text-align: center; border: 1px solid #ccc; border-radius: 4px; }
        input[type=range] { width: 100%; cursor: pointer; }
        
        .status-ready { color: #27ae60; } .status-wait { color: #95a5a6; }
    </style>
</head>
<body>

<div class="container">
    <h1 style="text-align: center;">ğŸ’° æŠ•è³‡æ¨¡æ“¬å¤§å¸« (Serverless)</h1>

    <div id="loginScreen">
        <h2>è«‹é¸æ“‡èº«åˆ†</h2>
        <input type="text" id="playerNameInput" placeholder="è¼¸å…¥æ‚¨çš„æš±ç¨±" style="width:100%; padding: 10px; margin-bottom: 10px;">
        <button class="btn" onclick="joinGame()">ä»¥ç©å®¶èº«åˆ†åŠ å…¥</button>
        <hr style="margin: 20px 0;">
        <input type="password" id="gmPasswordInput" placeholder="ç®¡ç†å“¡å¯†ç¢¼" style="width:100%; padding: 10px; margin-bottom: 10px;">
        <button class="btn btn-gm" onclick="loginGM()">ä»¥ç®¡ç†å“¡ (GM) ç™»å…¥</button>
    </div>

    <div id="playerUI" class="hidden">
        <div class="stats-bar">
            <div>å›åˆ <span id="pRound">1</span> / <span id="pMaxRound">5</span></div>
            <div>è³‡ç”¢ $<span id="pBalance">10,000</span></div>
        </div>
        <div class="chart-container"><canvas id="playerChart"></canvas></div>

        <div id="allocationControls">
           <h3>ğŸ“Š æœ¬å›åˆè³‡ç”¢é…ç½®</h3>
           <div id="dynamicSliders"></div>
           <div id="totalAllocMsg" style="text-align: center; font-weight: bold; color:green; margin: 10px 0;">ç¸½è¨ˆ: 100%</div>
           <button id="submitBtn" class="btn" onclick="submitAllocation()">æäº¤é…ç½®</button>
       </div>
       <div id="waitingMessage" class="hidden" style="text-align: center; padding: 20px; background: #e8f8f5; margin-top: 20px;">
           <h3 style="color: #27ae60;">âœ… é…ç½®å·²æäº¤</h3> <p>ç­‰å¾… GM çµç®—...</p>
       </div>
    </div>

    <div id="gmUI" class="hidden" style="border: 2px solid #e74c3c; padding: 20px; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between;">
            <h2>ğŸ® GM æ§åˆ¶å°</h2>
            <div>R<span id="gmRound">1</span> (è¤‡åˆ©:<span id="gmFreq">12</span>)</div>
        </div>
        <div class="chart-container" style="height: 350px;"><canvas id="gmChart"></canvas></div>

        <div class="row">
            <div class="col">
                <div style="background: #fff3cd; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                    <h4>ğŸ› ï¸ ç®¡ç†é¸é …</h4>
                    <div style="display: flex; gap: 5px;">
                        <input type="text" id="newAssetName" placeholder="åç¨±" style="flex:1;">
                        <button class="btn btn-small" style="background:#27ae60; color:white;" onclick="addAsset()">æ–°å¢</button>
                    </div>
                    <div id="gmAssetList" style="margin-top:10px;"></div>
                </div>
                <h3>ç©å®¶ç‹€æ…‹</h3>
                <div id="gmPlayerRows" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
            <div class="col">
                <div style="background: #eee; padding: 15px; border-radius: 8px;">
                    <h3>âš¡ è¨­å®šæ¼²è·Œ (%)</h3>
                    <div id="gmRateInputs"></div>
                    <button class="btn btn-gm" onclick="processRound()">çµç®—å›åˆ</button>
                </div>
                <div style="margin-top: 20px;">
                    å›åˆæ•¸: <input type="number" id="setRounds" value="5" style="width:50px;">
                    è¤‡åˆ©: <input type="number" id="setFreq" value="12" style="width:50px;">
                    <button class="btn" style="background:#7f8c8d; margin-top:5px;" onclick="resetGame()">ğŸ”„ é‡ç½®éŠæˆ²</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 1. CONFIGURATION ---
      const SUPABASE_URL = 'https://pbjgkxfieftfnjdxwdiu.supabase.co';
      const SUPABASE_KEY =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBiamdreGZpZWZ0Zm5qZHh3ZGl1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQyNTkxNDUsImV4cCI6MjA3OTgzNTE0NX0.YdHCt0Xd0XCL2sCYfd_-4jJolaQKgLKEACK_bohMx3o';

      // FIX 2: We name our client 'sb' instead of 'supabase' to avoid conflict with the library name
    const { createClient } = supabase;

      // FIX 2: We name our client 'sb' instead of 'supabase' to avoid conflict with the library name
    const sb = createClient(SUPABASE_URL, SUPABASE_KEY);

    // --- 2. STATE ---
    let myId = localStorage.getItem('my_invest_id');
    let myRole = 'player';
    let gameState = {};
    let assets = [];
    let players = [];
    
    // Charts
    let pChart = null;
    let gmChart = null;

    // --- 3. LOGIN LOGIC ---
    async function joinGame() {
        const name = document.getElementById('playerNameInput').value;
        if (!name) return alert('è«‹è¼¸å…¥åç¨±');

        const { data, error } = await sb
            .from('players')
            .insert([{ name: name }])
            .select()
            .single();

        if (error) return alert('ç™»å…¥å¤±æ•—: ' + error.message);
        
        myId = data.id;
        localStorage.setItem('my_invest_id', myId);
        myRole = 'player';
        initGame();
    }

    function loginGM() {
        if (document.getElementById('gmPasswordInput').value !== 'admin123') return alert('å¯†ç¢¼éŒ¯èª¤');
        myRole = 'gm';
        initGame();
    }

    async function initGame() {
        document.getElementById('loginScreen').classList.add('hidden');
        if (myRole === 'gm') document.getElementById('gmUI').classList.remove('hidden');
        else document.getElementById('playerUI').classList.remove('hidden');

        await fetchGameState();
        await fetchAssets();
        await fetchPlayers();


        // Setup Realtime Subscriptions (Using 'sb')
        
        // Setup Realtime Subscriptions (Using 'sb')
        sb.channel('game_channel')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'game_state' }, payload => {
                gameState = payload.new;
                updateUI();
                if(myRole === 'player') fetchPlayers(); 
            })
            .on('postgres_changes', { event: '*', schema: 'public', table: 'assets' }, fetchAssets)
            .on('postgres_changes', { event: '*', schema: 'public', table: 'players' }, fetchPlayers)
            .subscribe();

        updateUI();
    }

    // --- 4. DATA FETCHING ---
    async function fetchGameState() {
        const { data } = await sb.from('game_state').select('*').single();
        gameState = data;
        updateUI();
    }

    async function fetchAssets() {
        const { data } = await sb.from('assets').select('*').order('created_at');
        assets = data;
        renderAssets();
    }

    async function fetchPlayers() {
        // 1. Get latest list
        const { data } = await sb.from('players').select('*').order('balance', { ascending: false });
        players = data.filter(p => !p.is_gm); 
        
        // 2. GM View: Update List & Chart
        if (myRole === 'gm') {
            renderGMPlayerList();
            renderGMChart();
        } 
        // 3. Player View: Check if I still exist
        else {
            const me = players.find(p => p.id === myId);
            
            // LOGIC CHANGE: If 'me' is undefined, it means the GM reset the game and deleted me.
            if (!me) {
                // Clear local storage and show login screen
                localStorage.removeItem('my_invest_id');
                document.getElementById('playerUI').classList.add('hidden');
                document.getElementById('loginScreen').classList.remove('hidden');
                document.getElementById('playerNameInput').value = ''; 
                return; // Stop running
            }

            // Normal update if I still exist
            document.getElementById('pBalance').innerText = Math.floor(me.balance).toLocaleString();
            renderPlayerChart(me);
            
            if (me.submitted) {
                document.getElementById('allocationControls').classList.add('hidden');
                document.getElementById('waitingMessage').classList.remove('hidden');
            } else {
                document.getElementById('allocationControls').classList.remove('hidden');
                document.getElementById('waitingMessage').classList.add('hidden');
            }
        }
    }   
    // --- 5. RENDER UI ---
    function updateUI() {
        if(!gameState) return;
        const roundsDisplay = `${gameState.round}`;
        const maxDisplay = `${gameState.max_rounds}`;
        
        if (myRole === 'gm') {
            document.getElementById('gmRound').innerText = roundsDisplay;
            document.getElementById('gmFreq').innerText = gameState.compounding_freq;
            document.getElementById('setRounds').value = gameState.max_rounds;
            document.getElementById('setFreq').value = gameState.compounding_freq;
        } else {
            document.getElementById('pRound').innerText = roundsDisplay;
            document.getElementById('pMaxRound').innerText = maxDisplay;
        }
    }

    function renderAssets() {
        const pContainer = document.getElementById('dynamicSliders');
        pContainer.innerHTML = '';
        const gmList = document.getElementById('gmAssetList');
        const gmRates = document.getElementById('gmRateInputs');
        if(myRole === 'gm') { gmList.innerHTML = ''; gmRates.innerHTML = ''; }

        if (assets.length === 0) {
            pContainer.innerHTML = 'æš«ç„¡é¸é …';
            return;
        }

        assets.forEach((asset, idx) => {
            const isLast = idx === assets.length - 1;
            const div = document.createElement('div');
            div.className = 'control-group';
            div.innerHTML = `
                <div class="alloc-header"><span>${asset.name}</span> <span class="alloc-percent"><span id="val_${asset.id}">0</span>%</span></div>
                ${isLast 
                    ? `<small>(å‰©é¤˜)</small><input type="hidden" class="asset-slider" id="range_${asset.id}" data-id="${asset.id}" value="0">` 
                    : `<input type="range" class="asset-slider" id="range_${asset.id}" data-id="${asset.id}" value="0" min="0" max="100" oninput="updateAllocCalc()">`
                }`;
            pContainer.appendChild(div);

            if(myRole === 'gm') {
                const item = document.createElement('div');
                item.style = "display:flex; justify-content:space-between; margin-bottom:5px; border-bottom:1px solid #ddd;";
                item.innerHTML = `<span>${asset.name}</span> <button class="btn-small btn-gm" onclick="deleteAsset('${asset.id}')">X</button>`;
                gmList.appendChild(item);

                const rateDiv = document.createElement('div');
                rateDiv.style = "display:flex; justify-content:space-between; margin-bottom:5px;";
                rateDiv.innerHTML = `<label>${asset.name}</label> <input type="number" class="gm-rate-input" data-id="${asset.id}" value="0">`;
                gmRates.appendChild(rateDiv);
            }
        });
        
        if(myRole === 'player') {
            distributeDefault();
            updateAllocCalc();
        }
    }

    // --- 6. PLAYER LOGIC ---
    function distributeDefault() {
        const sliders = document.querySelectorAll('.asset-slider');
        if(sliders.length === 0) return;
        const avg = Math.floor(100 / sliders.length);
        sliders.forEach(s => s.value = avg);
    }

    function updateAllocCalc() {
        const sliders = document.querySelectorAll('.asset-slider[type=range]');
        let used = 0;
        sliders.forEach(s => used += parseInt(s.value || 0));
        
        const hiddenInput = document.querySelector('.asset-slider[type=hidden]');
        if(!hiddenInput) return;
        let remainder = 100 - used;
        
        sliders.forEach(s => document.getElementById(`val_${s.dataset.id}`).innerText = s.value);
        const lastVal = document.getElementById(`val_${hiddenInput.dataset.id}`);
        const btn = document.getElementById('submitBtn');

        if (remainder < 0) {
            document.getElementById('totalAllocMsg').innerText = `éŒ¯èª¤: ${used}%`;
            document.getElementById('totalAllocMsg').style.color = 'red';
            lastVal.innerText = "Err";
            btn.disabled = true;
        } else {
            document.getElementById('totalAllocMsg').innerText = "ç¸½è¨ˆ: 100%";
            document.getElementById('totalAllocMsg').style.color = 'green';
            lastVal.innerText = remainder;
            hiddenInput.value = remainder;
            btn.disabled = false;
        }
    }

    async function submitAllocation() {
        const sliders = document.querySelectorAll('.asset-slider');
        let updates = [];
        
        sliders.forEach(s => {
            updates.push({
                player_id: myId,
                asset_id: s.dataset.id,
                percent: parseInt(s.value || 0) // Ensure no nulls
            });
        });

        // 1. Send data
        const { error: allocError } = await sb.from('allocations').upsert(updates);
        if (allocError) return alert("Error sending allocation: " + allocError.message);

        // 2. Mark as submitted
        const { error: playerError } = await sb.from('players').update({ submitted: true }).eq('id', myId);
        if (playerError) return alert("Error updating status: " + playerError.message);
    }
    
    // --- 7. GM LOGIC ---
    async function addAsset() {
        const name = document.getElementById('newAssetName').value;
        if(name) {
            await sb.from('assets').insert([{ name }]);
            document.getElementById('newAssetName').value = '';
        }
    }

    async function deleteAsset(id) {
        if(confirm('ç¢ºå®šåˆªé™¤?')) await sb.from('assets').delete().eq('id', id);
    }

    async function processRound() {
        const inputs = document.querySelectorAll('.gm-rate-input');
        let rates = {};
        
        // Loop through inputs and safeguard against empty values
        inputs.forEach(i => {
            let val = parseFloat(i.value);
            if (isNaN(val)) val = 0; // Default to 0 if empty
            rates[i.dataset.id] = val;
        });

        console.log("Sending Rates:", rates); // Debugging log

        // Call the database function
        const { error } = await sb.rpc('process_round', { rates_json: rates });
        
        if(error) {
            console.error(error);
            alert('Error processing round: ' + error.message);
        } else {
            // Optional: Alert success or just let the UI update handle it
            console.log("Round processed successfully");
        }
    }

    async function resetGame() {
        const r = document.getElementById('setRounds').value;
        const f = document.getElementById('setFreq').value;
        if(confirm('é‡ç½®éŠæˆ²?')) {
            await sb.rpc('reset_game', { new_max_rounds: r, new_freq: f });
        }
    }

    function renderGMPlayerList() {
        const div = document.getElementById('gmPlayerRows');
        div.innerHTML = '';
        players.forEach(p => {
            div.innerHTML += `
                <div style="display:flex; justify-content:space-between; border-bottom:1px solid #eee; padding:5px;">
                    <span>${p.name} ${p.submitted ? 'âœ…' : 'â³'}</span>
                    <span>$${Math.floor(p.balance)}</span>
                </div>`;
        });
    }

    // --- 8. VISUALIZATION ENGINE (The Fix) ---
    
    // Calculates intermediate curve points between rounds
    function generateCompoundData(history, freq) {
        let dataPoints = [];
        let labels = [];

        if (history.length === 0) return { data: [], labels: [] };

        // Start point
        dataPoints.push(history[0]);
        labels.push('Start');

        // Iterate through each round transition
        for (let i = 0; i < history.length - 1; i++) {
            let startVal = parseFloat(history[i]);
            let endVal = parseFloat(history[i+1]);

            // Calculate per-step multiplier
            // If Freq is 1, steps=1. If Freq is 12, steps=12.
            // Ratio = End / Start
            let ratio = endVal / (startVal === 0 ? 1 : startVal);
            
            // Handle negative or zero logic gracefully
            if (startVal <= 0 || endVal <= 0) {
                 // Linear interpolation fallback for edge cases
                 let stepSize = (endVal - startVal) / freq;
                 for (let j = 1; j <= freq; j++) {
                    dataPoints.push(startVal + (stepSize * j));
                    labels.push(j === parseInt(freq) ? `R${i+1}` : '');
                 }
            } else {
                 let stepMultiplier = Math.pow(ratio, 1 / freq);
                 for (let j = 1; j <= freq; j++) {
                    let val = startVal * Math.pow(stepMultiplier, j);
                    dataPoints.push(val);
                    // Only label the integer rounds
                    labels.push(j === parseInt(freq) ? `R${i+1}` : '');
                 }
            }
        }
        return { data: dataPoints, labels: labels };
    }

    const chartOpts = { 
        responsive: true, 
        maintainAspectRatio: false, 
        elements: { 
            line: { tension: 0.4 },
            point: { radius: 0, hitRadius: 10 } // Hide intermediate dots, keep clickable
        } 
    };

    function renderPlayerChart(me) {
        if(pChart) pChart.destroy();
        
        // Use the new Interpolation Function
        const { data, labels } = generateCompoundData(me.history, gameState.compounding_freq);

        pChart = new Chart(document.getElementById('playerChart'), {
            type: 'line',
            data: { 
                labels: labels, 
                datasets: [{ 
                    label: 'æˆ‘çš„è³‡ç”¢', 
                    data: data, 
                    borderColor: '#3498db', 
                    fill: true,
                    // Show dot only on rounds
                    pointRadius: (ctx) => ctx.dataIndex % gameState.compounding_freq === 0 ? 3 : 0
                }] 
            },
            options: chartOpts
        });
    }

    function renderGMChart() {
        if(gmChart) gmChart.destroy();
        if(players.length === 0) return;
        
        // Calculate the longest history to generate base labels
        const maxHistoryPlayer = players.reduce((prev, current) => (prev.history.length > current.history.length) ? prev : current);
        const { labels } = generateCompoundData(maxHistoryPlayer.history, gameState.compounding_freq);
        
        const colors = ['#e74c3c', '#3498db', '#9b59b6', '#2ecc71', '#f1c40f'];
        
        const datasets = players.map((p, i) => {
            const curve = generateCompoundData(p.history, gameState.compounding_freq);
            return {
                label: p.name,
                data: curve.data,
                borderColor: colors[i % colors.length],
                fill: false,
                pointRadius: (ctx) => ctx.dataIndex % gameState.compounding_freq === 0 ? 3 : 0
            };
        });

        gmChart = new Chart(document.getElementById('gmChart'), {
            type: 'line',
            data: { labels: labels, datasets: datasets },
            options: chartOpts
        });
    }
</script>
</body>
</html>